---
title: "implementing priors in glmmTMB"
---

```{r pkgs, message = FALSE}
library(brms)
if (!"priors" %in% names(formals(glmmTMB::glmmTMB))) {
    remotes::install_github("glmmTMB/glmmTMB/glmmTMB@priors")
}
library(glmmTMB)
library(lme4)
library(blme)
library(broom.mixed)
library(purrr)
library(dplyr)
library(ggplot2); theme_set(theme_bw())
```

It seems useful to use the API/user interface from `brms`

* downside: `brms`has lots of downstream dependencies that `glmmTMB` doesn't
    * might be able to copy the relevant code (the full [file](https://github.com/paul-buerkner/brms/blob/master/R/priors.R) is 2210 lines (!), but this includes documentation and a lot of code we don't need ...
    ```{r deps}
	rd <- \(x) tools::package_dependencies("brms", recursive = TRUE)[[x]]
    ## rd <- \(x) packrat:::recursivePackageDependencies(x, ignores = "", lib.loc =    .libPaths()[1])
    ## not sure why packrat and tools get different answers, but difference
    ## doesn't matter much
    brms_dep <- rd("brms")
    glmmTMB_dep <- rd("glmmTMB")
    length(setdiff(brms_dep, glmmTMB_dep))
    ```
* at its simplest, this is just a front-end for a data frame
```{r priors}
bprior <- c(prior_string("normal(0,10)", class = "b"),
            prior(normal(1,2), class = b, coef = treat),
            prior_(~cauchy(0,2), class = ~sd,
                   group = ~subject, coef = ~Intercept))
str(bprior)
```
We probably only need to pay attention to the columns `prior`, `class`, `coef`, `group`. For our purposes, `prior` is the name and parameters; `class` will be the name of the parameter vector; `coef` will specify an index within the vector (could be a number or name?)
	
`TMB`-side data structure:

* vector of prior codes
    * we need a new `enum`, `.valid_priors`: see `make-enum` in the Makefile
* list of parameter vectors? or `prior_p1`, `prior_p2`, `prior_p3` (do any prior families have more than two parameters? What about non-scalar parameters, e.g. Wishart priors ... ???)
* vector of parameter codes (another `enum`?) (`beta`, `theta`, `thetaf` ... `b` ?)
* each index (corresponding to `coef`) is scalar, either NA (prior over all elements) or integer (a specific element)

* new loop after loglik loop to add (negative log-)prior components: loop over prior spec

## tests

### Culcita example 

from Bolker chapter in Fox et al (regularize nearly complete separation)

```{r culcita}
cdat <- readRDS(system.file("example_files", "culcita.rds", package = "glmmTMB"))
## identified as extreme residual in https://bbolker.github.io/mixedmodels-misc/ecostats_chap.html
cdatx <- cdat[-20,]
form <- predation~ttt+(1|block)
cmod_glmer <- glmer(form, data=cdatx, family=binomial)
cmod_blmer <- bglmer(form, data=cdatx, family=binomial,
                    fixef.prior = normal(cov = diag(9,4)))
cmod_glmmTMB <- glmmTMB(form, data=cdatx, family=binomial)
cprior <- data.frame(prior = "normal(0, 3)",
                     class = "beta",
                     coef = "")
cmod_glmmTMB_p <- glmmTMB(form, data=cdatx, family=binomial, priors = cprior)
all.equal(coef(summary(cmod_blmer)),
          coef(summary(cmod_glmmTMB_p))$cond,
          tolerance = 5e-2)
cmods <- ls(pattern = "cmod_[bg].*")
cmod_list <- mget(cmods) |> setNames(gsub("cmod_", "", cmods))
```

```{r culcita_comp}
cres <- (purrr::map_dfr(cmod_list,
                        ~tidy(., conf.int = TRUE, effects = "fixed"),
                        .id = "model")
    |> select(model, term, estimate, lwr = conf.low, upr = conf.high)
)
ggplot(cres, aes(x = estimate, y = term, colour = model)) +
    geom_pointrange(aes(xmin = lwr, xmax = upr),
                    position = position_dodge(width = 0.5))
```

### Gopher tortoise example 

from Bolker chapter in Fox et al (regularize singular fit)

```{r gophertortoise}
gdat <- readRDS(system.file("example_files", "gophertortoise.rds", package = "glmmTMB"))
form <- shells~prev+offset(log(Area))+factor(year)+(1|Site)
gmod_glmer <- glmer(form , family=poisson, data=gdat)
gmod_blmer <- bglmer(form, family=poisson, data=gdat)
## cov.prior = gamma(shape = 2.5, rate = 0, common.scale = TRUE, posterior.scale = "sd"))
gmod_glmmTMB <- glmmTMB(form, family = poisson, data = gdat) ## 1e-5
## blmer default corresponds to gamma(Inf, 2.5)
gprior <- data.frame(prior = "gamma(1e8, 2.5)",
                     class = "theta",
                     coef = "")
gmod_glmmTMB_p <- glmmTMB(form, family = poisson, data = gdat, priors = gprior)
vc1 <- c(VarCorr(gmod_glmmTMB_p)$cond$Site)
vc2 <- c(VarCorr(gmod_blmer)$Site)
all.equal(vc1, vc2, tolerance = 5e-4)
gmods <- ls(pattern = "gmod_[bg].*")
gmod_list <- mget(cmods) |> setNames(gsub("gmod_", "", gmods))

```

```{r gopher_comp, eval = FALSE}
pp <- profile(gmod_blmer, which = "theta_", devtol = Inf)
lattice::xyplot(pp)
confint(pp)
pp <- profile(gmod_glmer, which = "theta_", devtol = Inf)
cres <- (purrr::map_dfr(gmod_list,
                        ~tidy(., conf.int = TRUE, effects = "ran_pars",
                              conf.method = "profile", devtol = Inf),
                        .id = "model")
    |> select(model, term, estimate, lwr = conf.low, upr = conf.high)
)
ggplot(cres, aes(x = estimate, y = term, colour = model)) +
    geom_pointrange(aes(xmin = lwr, xmax = upr),
                    position = position_dodge(width = 0.5))
```

`blme` defaults: Wishart(dim + 2.5), or gamma(2.5). For dim = 1 (scalar), Wishart(n) corresponds to chi-squared(n), or gamma(shape = n/2, scale = n/2).  Chung et al propose `gamma(2, Inf)`; not sure why `blme` uses `gamma(2.5)` instead? or if specified via Wishart, shape = 3.5 â†’ gamma shape of 1.75?

## To do/Fix me

- try to get internal structure of priors fixed before release, otherwise `up2date` might get annoying ...
- document synonyms
- why is `blmer` profile CI failing (in `broom.mixed`, but not externally?)
- figure out/document `blme` default priors
- move this document to a vignette?
- add tests!
- add prior info to model info, print(), summary() output
- document that gamma is applied on exp() scale
   - move prior info to a separate man page?
- implement elementwise priors
- allow multivariate (joint) priors on parameter vectors rather than iid priors?
     - esp for correlation matrices: LKJ, Wishart etc. (from Mikael Jagan [here](https://github.com/jaganmn/misc/tree/master/tmb_distributions))

- test!
- easier to work out number of parameters per prior on the R side and pass it to glmmTMB as a prior-wise vector?

