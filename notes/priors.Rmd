---
title: "implementing priors in glmmTMB"
---

```{r pkgs}
library(brms)
if (!"priors" %in% names(formals(glmmTMB::glmmTMB))) {
    remotes::install_github("glmmTMB/glmmTMB/glmmTMB@priors")
}
library(glmmTMB)
library(lme4)
library(broom.mixed)
library(purrr)
library(dplyr)
library(ggplot2); theme_set(theme_bw())
```

It seems useful to use the API/user interface from `brms`

* downside: `brms`has 85 downstream dependencies that `glmmTMB` doesn't
    * might be able to copy the relevant code (the full [file](https://github.com/paul-buerkner/brms/blob/master/R/priors.R) is 2210 lines (!), but this includes documentation and a lot of code we don't need ...
    ```{r deps}
    rd <- \(x) packrat:::recursivePackageDependencies(x, ignores = "", lib.loc =    .libPaths()[1])
    brms_dep <- rd("brms")
    glmmTMB_dep <- rd("glmmTMB")
    length(setdiff(brms_dep, glmmTMB_dep))
    ```
* at its simplest, this is just a front-end for a data frame
```{r priors}
bprior <- c(prior_string("normal(0,10)", class = "b"),
            prior(normal(1,2), class = b, coef = treat),
            prior_(~cauchy(0,2), class = ~sd,
                   group = ~subject, coef = ~Intercept))
str(bprior)
```
We probably only need to pay attention to the columns `prior`, `class`, `coef`, `group`. For our purposes, `prior` is the name and parameters; `class` will be the name of the parameter vector; `coef` will specify an index within the vector (could be a number or name?)
	
`TMB`-side data structure:

* vector of prior codes
    * we need a new `enum`, `.valid_priors`: see `make-enum` in the Makefile
* list of parameter vectors? or `prior_p1`, `prior_p2`, `prior_p3` (do any prior families have more than two parameters? What about non-scalar parameters, e.g. Wishart priors ... ???)
* vector of parameter codes (another `enum`?) (`beta`, `theta`, `thetaf` ... `b` ?)
* each index (corresponding to `coef`) is scalar, either NA (prior over all elements) or integer (a specific element)

* new loop after loglik loop to add (negative log-)prior components: loop over prior spec

## tests

### Culcita example 

from Bolker chapter in Fox et al (regularize nearly complete separation)

```{r culcita}
cdat <- readRDS(system.file("example_files", "culcita.rds", package = "glmmTMB"))
## identified as extreme residual in https://bbolker.github.io/mixedmodels-misc/ecostats_chap.html
cdatx <- cdat[-20,]
form <- predation~ttt+(1|block)
cmod_glmer <- glmer(form, data=cdatx, family=binomial)
cmod_blmer <- bglmer(form, data=cdatx, family=binomial,
                    fixef.prior = normal(cov = diag(9,4)))
cmod_glmmTMB <- glmmTMB(form, data=cdatx, family=binomial)
cprior <- data.frame(prior = "normal(0, 3)",
                     class = "beta",
                     coef = "")
cmod_glmmTMB_p <- glmmTMB(form, data=cdatx, family=binomial, priors = cprior)
all.equal(coef(summary(cmod_blmer)),
          coef(summary(cmod_glmmTMB_p))$cond,
          tolerance = 5e-2)
cmods <- ls(pattern = "cmod_.*")
cmod_list <- mget(cmods) |> setNames(gsub("cmod_", "", cmods))
```

```{r culcita_comp}
cres <- (purrr::map_dfr(cmod_list,
                        ~tidy(., conf.int = TRUE, effects = "fixed"),
                        .id = "model")
    |> select(model, term, estimate, lwr = conf.low, upr = conf.high)
)
ggplot(cres, aes(x = estimate, y = term, colour = model)) +
    geom_pointrange(aes(xmin = lwr, xmax = upr),
                    position = position_dodge(width = 0.5))
```

### Gopher tortoise example 

from Bolker chapter in Fox et al (regularize singular fit)

```{r gophertortoise}
gdat <- readRDS(system.file("example_files", "gophertortoise.rds", package = "glmmTMB"))
form <- shells~prev+offset(log(Area))+factor(year)+(1|Site)
gmod_lmer <- glmer(form , family=poisson, data=gdat)
gmod_blmer <- bglmer(form, family=poisson, data=gdat)
gmod_glmmTMB <- glmmTMB(form, family = poisson, data = gdat) ## 1e-5
## blmer default corresponds to gamma(Inf, 2.5)
gprior <- data.frame(prior = "gamma(1e8, 2.5)",
                     class = "theta",
                     coef = "")
gmod_glmmTMB_p <- glmmTMB(form, family = poisson, data = gdat, priors = gprior)
vc1 <- c(VarCorr(gmod_glmmTMB_p)$cond$Site)
vc2 <- c(VarCorr(gmod_blmer)$Site)
all.equal(vc1, vc2, tolerance = 5e-4)
```

## To do/Fix me

- add tests!
- add prior info to model info, print(), summary() output
- document that gamma is applied on exp() scale
   - move prior info to a separate man page?
- implement elementwise priors
- allow multivariate (joint) priors on parameter vectors rather than iid priors?
     - esp for correlation matrices: LKJ, Wishart etc. (from Mikael Jagan [here](https://github.com/jaganmn/misc/tree/master/tmb_distributions))

- test!
- easier to work out number of parameters per prior on the R side and pass it to glmmTMB as a prior-wise vector?

